The following code snippet is a cross-platform implementation of atomic float addition in OpenCL.
The implementation uses hardware-supported functions whereever possible and implements a fallback algorithm that is faster than most commonly used approaches.
I am sharing it here for other developers to use as a single function to handle atomic addition on all platforms uniformly.


<pre class="github-dark-default" style="background-color:#0d1117;color:#e6edf3;font-size:0.7rem;overflow-x:scroll;padding:10px;scrollbar-width: thin" tabindex="0"><code><div class="line"><span style="color:#FF7B72">inline</span><span style="color:#FF7B72"> void</span><span style="color:#D2A8FF"> atomic_add_f</span><span style="color:#E6EDF3">(</span><span style="color:#FF7B72">volatile</span><span style="color:#E6EDF3"> __global </span><span style="color:#FF7B72">float*</span><span style="color:#FFA657"> addr</span><span style="color:#E6EDF3">, </span><span style="color:#FF7B72">const</span><span style="color:#FF7B72"> float</span><span style="color:#FFA657"> val</span><span style="color:#E6EDF3">) {</span></div><div class="line"><span style="color:#FF7B72">	#if</span><span style="color:#FF7B72"> defined</span><span style="color:#E6EDF3">(</span><span style="color:#D2A8FF">cl_nv_pragma_unroll</span><span style="color:#E6EDF3">)</span><span style="color:#8B949E"> // use hardware-supported atomic addition on Nvidia GPUs with inline PTX assembly</span></div><div class="line"><span style="color:#D2A8FF">		float</span><span style="color:#D2A8FF"> ret</span><span style="color:#E6EDF3">; </span><span style="color:#D2A8FF">asm</span><span style="color:#D2A8FF"> volatile</span><span style="color:#E6EDF3">(</span><span style="color:#A5D6FF">"atom.global.add.f32 </span><span style="color:#FFA198;font-style:italic">%</span><span style="color:#A5D6FF">0,[</span><span style="color:#FFA198;font-style:italic">%</span><span style="color:#A5D6FF">1],</span><span style="color:#FFA198;font-style:italic">%</span><span style="color:#A5D6FF">2;"</span><span style="color:#E6EDF3">:</span><span style="color:#A5D6FF">"=f"</span><span style="color:#E6EDF3">(</span><span style="color:#D2A8FF">ret</span><span style="color:#E6EDF3">):</span><span style="color:#A5D6FF">"l"</span><span style="color:#E6EDF3">(</span><span style="color:#D2A8FF">addr</span><span style="color:#E6EDF3">),</span><span style="color:#A5D6FF">"f"</span><span style="color:#E6EDF3">(</span><span style="color:#D2A8FF">val</span><span style="color:#E6EDF3">):</span><span style="color:#A5D6FF">"memory"</span><span style="color:#E6EDF3">);</span></div><div class="line"><span style="color:#FF7B72">	#elif</span><span style="color:#FF7B72"> defined</span><span style="color:#E6EDF3">(</span><span style="color:#D2A8FF">__opencl_c_ext_fp32_global_atomic_add</span><span style="color:#E6EDF3">)</span><span style="color:#8B949E"> // use hardware-supported atomic addition on some Intel GPUs</span></div><div class="line"><span style="color:#D2A8FF">		atomic_fetch_add</span><span style="color:#E6EDF3">((</span><span style="color:#D2A8FF">volatile</span><span style="color:#D2A8FF"> global</span><span style="color:#D2A8FF"> atomic_float</span><span style="color:#FF7B72">*</span><span style="color:#E6EDF3">)</span><span style="color:#D2A8FF">addr</span><span style="color:#E6EDF3">, </span><span style="color:#D2A8FF">val</span><span style="color:#E6EDF3">);</span></div><div class="line"><span style="color:#FF7B72">	#elif</span><span style="color:#D2A8FF"> __has_builtin</span><span style="color:#E6EDF3">(</span><span style="color:#D2A8FF">__builtin_amdgcn_global_atomic_fadd_f32</span><span style="color:#E6EDF3">)</span><span style="color:#8B949E"> // use hardware-supported atomic addition on some AMD GPUs</span></div><div class="line"><span style="color:#D2A8FF">		__builtin_amdgcn_global_atomic_fadd_f32</span><span style="color:#E6EDF3">(</span><span style="color:#D2A8FF">addr</span><span style="color:#E6EDF3">, </span><span style="color:#D2A8FF">val</span><span style="color:#E6EDF3">);</span></div><div class="line"><span style="color:#FF7B72">	#else</span><span style="color:#8B949E"> // fallback emulation: https://forums.developer.nvidia.com/t/atomicadd-float-float-atomicmul-float-float/14639/5</span></div><div class="line"><span style="color:#FF7B72">		float</span><span style="color:#E6EDF3"> old </span><span style="color:#FF7B72">=</span><span style="color:#E6EDF3"> val; </span><span style="color:#FF7B72">while</span><span style="color:#E6EDF3">((old</span><span style="color:#FF7B72">=</span><span style="color:#D2A8FF">atomic_xchg</span><span style="color:#E6EDF3">(addr, </span><span style="color:#D2A8FF">atomic_xchg</span><span style="color:#E6EDF3">(addr, </span><span style="color:#79C0FF">0.0</span><span style="color:#FF7B72">f</span><span style="color:#E6EDF3">)</span><span style="color:#FF7B72">+</span><span style="color:#E6EDF3">old))</span><span style="color:#FF7B72">!=</span><span style="color:#79C0FF">0.0</span><span style="color:#FF7B72">f</span><span style="color:#E6EDF3">);</span></div><div class="line"><span style="color:#FF7B72">	#endif</span></div><div class="line"><span style="color:#E6EDF3">}</span></div></code></pre>

But why does this need to exist?
Atomic addition of integers is a core part of the OpenCL specification and is included in virtually all implementations of the spec.
Atomic addition of floating point numbers however is not officially part of the specification, and only a handful of atomic operations defined in the core spec accept floats at all (one of them being `atomic_xchg()`, used in the above implementation).
Because atomic float addition is a very useful tool and many algorithms depend on it, numerous vendors have implemented their own hardware-supported versions, sometimes with accompanying OpenCL extensions.
These are not standardized however and code using a specific extension will never be universally cross-platform. The above snippet defines a singular inline function that uses macros to expand only the supported implementation on the platform the code is compiled on.
If no compatible implementation is detected, the function expands into a functionally identical (but slower than native) implementation that is up to an order of magnitude(!!!) faster than common workarounds<sup><a id="1t" href="#1b">[1]</a></sup>.
I hope this code saves some headaches when working with atomic float addition! If you have any improvements for or thoughts on the code above feel free to reach out to me, preferably over the [Fediverse](https://mastodon.social/@pipinspace). I want to thank [ProjectPhysX](https://github.com/ProjectPhysX) for compiling the implementations and especially for providing the PTX assembly for NVidia GPUs!

<a id="1b" href="#1t">[1]</a>: Yes, really! Many implementations loose an immense amount of speed when conflicts between threads occur. One of the more common implementations uses only one `atomic_cmpxchg()` call in a while loop that checks for successful addition. This can quickly lead to race conditions where threads have to "retry" the addition every time another thread writes a new value to memory in between, possibly for hundreds of times. This completely degrades performance and in my tests is about 8000 times slower than the  fallback algorithm in the snippet above.